In this assignment, we were tasked with writing 4 functions involving grammars:
convert_grammar,parse_tree_leaves, make_matcher, and make_parser. 
The first two functions, convert_grammar and parse_tree_leaves were simple 
enough. For HW1, we were given grammars in the form of a start symbol 
paired with a list of rules, where rules consist of nonterminal symbol paired
with a list of symbols. For HW2, instead of a list of rules, the grammar was 
supposed to be composed of a production function which, given a symbol, 
returns a list of right associated with that symbol. The conversion was 
simple enough, as I simply wrote the search function and then returned it 
using a lambda function. This also could've been done using currying.

Next, we were introduced to the concept of a parse_tree, which is an example
of a recursive type. Each tree object can be either a Node, which consists of 
a nonterminal symbol paired with a list of tree objects (the node's children), 
or a Leaf, which consists of just a terminal symbol. The parse_tree_leaves 
function required a simple traversal of the tree. However, this was made 
slightly more difficult due to the instruction that we were to avoid iteration. 
Thus, I used mutually recursive functions: one to go "down" the tree and one 
to go "across".

After completing these "warm-ups," we arrived at the real problem: constructing
a matcher and a parser. In the spec, we were given the hint that the two 
functions were closely related, and doing one would make it much easier to 
do the other. Furthermore, it was suggested that we may want to use 
make_matcherin make_parser, or vice versa. Both of these functions were quite 
difficult, and as such, it was difficult for me to "plan" the way I would solve 
the problem.

I first tackled make_matcher. I spent a very long time on this problem, 
and it started with simply understanding the expected behavior of the function.
Given a fragment (a list of terminal symbols), a grammar, and an acceptor, 
a matcher would traverse the grammar in order from the start symbol searching
for a prefix of the fragment. The acceptor would be called on the suffix of 
every found prefix found until a valid one is found. The main difficulty in 
make_matcher was traversing the grammar correctly since it was imperative that 
we return the "first" accepted suffix. While this seems simple enough with 
a backtracking approach, I had to be careful about calling the acceptor. 
To elaborate, the acceptor should only be called when the current prefix 
"becomes invalid." In other words, the search only stops at the end of each 
prefix (for example when a non-matching terminal symbol was found). This became 
a problem because of the recursive nature of the function: in the base case, I 
wanted to call the acceptor as the terminating case of the function, but in the 
recursive case, I wanted to pass the current information (remaining fragment, 
current symbol/list of symbols, etc) up the recursive tree to previous calls, 
allowing the current prefix to continue as long as possible.

I was stuck on this problem for quite a while, and I finally found a solution 
using some of the resources made available online by the TAs (if you're 
reading this, thank you!). Specifically, Discussion 1B's Week 3
material on acceptors gave me the idea of CPS, or "continuation passing 
style". In this case, CPS entailed passing an additional (curried) recursive 
call as the "acceptor" for the deeper recursive calls. Thus, I consistently 
called this acceptor variable as the terminating case, and the function would
follow this "acceptor" back up the recursive tree whenever necessary. Once
I realized this, the solution made a lot of sense, but I definitely didn't 
think of it initially (although maybe I should've).

Finally, I arrived to make_parser. The main topic of the report given in the 
spec is the construction of make_parser in relation to make_matcher, or 
vice versa. I assume many other students used make_matcher in make_parser, but 
I didn't find any easy way to do this. I found that the functionality of 
make_matcher was too different from the requirements make_parser: I could 
use the same traversal as that from make_matcher, but I would need to change 
the return value of the function. That left me with the option of modularizing
my make_matcher function for reuse in make_parser, but I found this to be 
quite difficult, perhaps partially due to the style of OCaml coding used in 
this assignment. For example, it'd be pretty hard to create the same recursive
behavior using multiple helper functions without passing many parameters 
between them and using many conditional statements. I could've just 
created a general traversal function with a parameter that determined the 
return value, but this also would've required an extra conditional. Still, I 
suspect it's possible, but I decided that it wasn't worth it and might even 
make the code less clean. 

Thus, I ended up just copying the function and changing the return value. 
I still was unclear on what exactly this return value should be. Then, I again
used the Discussion 1B resources and came across the concept of tail recursion,
which allowed me to come up with an ordered list of rules traversed during the 
function call on the given fragment. From there, it was relatively easy to come 
up with a parse tree using a mutually recursive function in the vein of part 2, 
except creating the tree-leaves from the symbols this time. 

In addition to the duplication that I discussed earlier between make_matcher 
and make_parser.My solution has a couple weaknesses. However, the more 
significant weaknesses include the types of grammars that my solution cannot 
handle. In particular, my solution cannot handle left recursion. Based 
on Piazza, it was my impression that this weakness was acceptable since these 
grammars wouldn't be considered "context-free". Still, a non-terminal symbol 
that leads to itself would lead to infinite recursion. 

Sources: ccle.ucla.edu/mod/resource/view.php?id=2964316
ccle.ucla.edu/mod/resource/view.php?id=2946593
ccle.ucla.edu/pluginfile.php/3382012/mod_resource/content/0/Week2%20Miscs.pdf
ccle.ucla.edu/pluginfile.php/3376375/mod_resource/content/0/Week3%20Matcher%20
and%20CPS.ml
ccle.ucla.edu/pluginfile.php/3401206/mod_resource/content/0/Week3%20Acceptor.pdf
ccle.ucla.edu/pluginfile.php/3385501/mod_resource/content/0/Week2%20Discussion%
20Notes.ml
github.com/CS131-TA-team/UCLA_CS131_CodeHelp/tree/master/OCaml/hw2


